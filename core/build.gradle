import org.gradle.plugins.ide.idea.model.IdeaModel

// For those who want the bleeding edge
buildscript {
    repositories {
        flatDir { dirs '../deps' }
        jcenter()
        //maven { url = "http://files.minecraftforge.net/maven" }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-Alchemy'
    }
}

plugins {
    id "com.dorongold.task-tree" version "1.3"
}
apply plugin: 'net.minecraftforge.gradle.forge'
def ideaConv = (IdeaModel) project.getExtensions().getByName("idea")
ideaConv.module.scopes.get("RUNTIME").get("plus").remove(project.configurations.forgeGradleGradleStart)
ideaConv.module.scopes.get("COMPILE").get("plus").add(project.configurations.forgeGradleGradleStart)

def javaConv = (JavaPluginConvention) project.convention.plugins.get("java")
def m = javaConv.sourceSets.main
m.compileClasspath += configurations.forgeGradleGradleStart

sourceJar.enabled = false

apply plugin: 'maven'
apply plugin: 'java'

configurations {
    shade
    compile.extendsFrom shade
    compileOnly.extendsFrom(runtime)
}
dependencies {
    compile project(":internal-utils")
    compile fileTree(dir: 'mods', include: ['*.jar'])
    //compileOnly files(project.configurations.forgeGradleGradleStart.getResolvedConfiguration().files)
    // shade 'org.jooq:jool:+'
}

apply from: 'ast.gradle'

version = config.mod_version
group= "com.github.mickeyxiami.alchemy" // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = "Alchemy-${config.show_version}"

version = "${config.minecraft_version}-${config.mod_version}.${config.dev_version}"
config.build_number = config.dev_version

minecraft {
    version = config.minecraft_version + "-" + config.forge_version
    runDir = "run"
    
    // the mappings can be changed at any time, and must be in the following format.
    // snapshot_YYYYMMDD   snapshot are built nightly.
    // stable_#            stables are built at the discretion of the MCP team.
    // Use non-default mappings at your own risk. they may not allways work.
    // simply re-run your setup task after changing the mappings to update your workspace.
    mappings = project.config.mappings_version
    // makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.
    def buildnum = (config.build_number != "") ? config.build_number : "?"
    replace '@MOD_VERSION@', config.mod_version + '.' + buildnum
    replace '@DEV_VERSION@', buildnum
    replaceIn 'AlchemyConstants.java'
    
}

recompileMc {
    doFirst {
        System.setProperty("java.ext.dirs", "")
        def at = 'src/main/resources/META-INF/at.cfg'
        doAccessTransformer(file(at), getInSources())
        dirList('dlcs').each { File dlc -> doAccessTransformer(new File(dlc, at), getInSources()) }
    }
}

void doAccessTransformer(File at, File input) {
    if (!at.exists())
        return
    println "Find at: ${at.path}"
    def lines = com.google.common.base.Joiner.on('\n').join(org.apache.commons.io.IOUtils.readLines(new FileInputStream(at)))
    def mapping = VERConsts['getMapping'](lines)
    mapping.values().forEach { it.forEach { println it } }
    def zis = new java.util.zip.ZipInputStream(new java.io.FileInputStream("${input.path}"))
    def zos = new java.util.zip.ZipOutputStream(new java.io.FileOutputStream("${input.path}".replace('.jar', '-fixed.jar')))
    def result = new java.util.LinkedList()
    for (java.util.zip.ZipEntry entry; (entry = zis.nextEntry) != null;) {
        zos.putNextEntry(entry)
        if (entry.name.endsWith(".java")) {
            def name = entry.name.replace('/', '.').replace('.java', '')
            org.apache.commons.io.IOUtils.write(VERConsts['doAccessTransformer'](
                    com.google.common.base.Joiner.on('\n').join(org.apache.commons.io.IOUtils.readLines(zis)), name, mapping, result),
                    zos, "utf-8")
        } else
            org.apache.commons.io.IOUtils.copy(zis, zos)
    }
    zis.close()
    zos.finish()
    zos.close()
    def flag
    println "------------------------------------------------------------------------------------------------------------------"
    mapping.values().forEach { it.stream().filter { !result.contains(it) && !it.runtime }.forEach { flag = true; println it } }
    if (flag)
        throw new RuntimeException("At is not working properly")
    input.delete()
    file(input.path.replace(".jar", "-fixed.jar")).renameTo(input)
}

task sourcesZip(type: Zip) {
    baseName = "${archivesBaseName}-core"
    from fileTree(dir: 'src/main/java/')
    include '**/'
    classifier = 'sources'
    from 'LICENSE'
    destinationDir jar.destinationDir
}

compileJava {
    sourceCompatibility = '10'
    targetCompatibility = '10'
    
    options.encoding = 'utf-8'
    options.fork = true
    doFirst {
        options.forkOptions.with {
            def jdt = configurations.ecj.asPath
            executable = 'java'
            def lib = new java.util.TreeSet(sourceSets.main.compileClasspath.getFiles())
            sourceSets.main.compileClasspath = new org.gradle.api.internal.file.UnionFileCollection(lib)
            def toSort = { it.toString().contains("forgeSrc-") ? -1 : 0 }
            lib.sort { a, b -> toSort(a) - toSort(b) }
            println "Main Compile Class Path: "
            sourceSets.main.compileClasspath.each { println it }
            source = sourceSets.main.java.exclude { checkPackageName(it.getFile().toString().replace("\\", ".").replace("/", ".")) }
            println "Main Compile Path: "
            source.each { println it }
            println "JDT-ECJ lib path: " + jdt
            jvmArgs = [ '-cp', jdt, 'org.eclipse.jdt.internal.compiler.batch.Main', '-nowarn', '--add-modules', 'jdk.unsupported', '--add-exports', 'java.base/jdk.internal.reflect=ALL-UNNAMED' ]
        }
    }
}

boolean checkPackageName(String packageName) {
    return packageName.contains("index.alchemy.core.run") || packageName.contains("index.alchemy.ztest") || packageName.contains("index.alchemy.development")
}



void deobf(String inputName) {
    def outputName = inputName.replace('dev', 'deobf')
    def mapping = new net.md_5.specialsource.JarMapping()
    def inputFile = file("deobf/${inputName}")
    def outputFile = file("deobf/${outputName}")
    def remapper = new net.md_5.specialsource.JarRemapper(null, mapping)
    def inputJar = net.md_5.specialsource.Jar.init(inputFile)
    def inheritanceProviders = new net.md_5.specialsource.provider.JointProvider()
    def jarProvider = new net.md_5.specialsource.provider.JarProvider(inputJar)
    inheritanceProviders.add(jarProvider)
    mapping.loadMappings(config.srg_mcp)
    mapping.setFallbackInheritanceProvider(inheritanceProviders)
    remapper.remapJar(inputJar, outputFile)
}

task deobf << {
    fileList('deobf').each { deobf(it.name) }
}

def commonManifest = {
    attributes 'FMLAT' : 'alchemy_at.cfg',
               'FMLCorePlugin': 'index.alchemy.core.AlchemyEngine', 
               'FMLCorePluginContainsFMLMod': 'true'
}

jar {
    baseName = "${archivesBaseName}-core"
    manifest commonManifest
    classifier = 'universal'
    
    from 'README.txt'
	
	configurations.shade.each { dep ->
        from(project.zipTree(dep)){
            exclude 'META-INF', 'META-INF/**'
        }
    }
}

processResources {
    // this will ensure that this task is redone when the versions change.
    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version

    // replace stuff in mcmod.info, nothing else
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'
                
        // replace version and mcversion
        expand 'version':project.version, 'mcversion':project.minecraft.version
    }
        
    // copy everything else, thats not the mcmod.info
    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}
